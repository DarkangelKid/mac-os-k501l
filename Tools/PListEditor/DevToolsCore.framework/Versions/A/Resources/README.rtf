{\rtf1\ansi\ansicpg1252\cocoartf991
{\fonttbl\f0\fnil\fcharset0 Verdana;\f1\fswiss\fcharset0 ArialMT;}
{\colortbl;\red255\green255\blue255;}
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\qj\pardirnatural

\f0\b\fs32 \cf0 Target Snapshot Classes
\b0 \

\f1\fs24 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\slleading20\sb60\sa60\qj\pardirnatural

\fs28 \cf0 The classes in this folder implement "target snapshots", which are immutable data structures that are created on the main thread and passed down as input to the background build thread.  This approach ensures that the build thread is working with self-consistent input data, and also avoids a need for fine-grained locking of the project model (because fine-grained locking is error-prone and non-performant).\
Instead, the dependency analysis logic (running on the build thread) gets all immutable configuration data from the target snapshot, and just uses locking accessor methods to set build state as it does its processing.\
In general, there is a target snapshot class for each main model object class.  One notable exception is that in the snapshot, the target is the root object; in fact, the project is not represented at all.  Instead, the target keeps all the information for itself and for the project (in this sense, the target snaphot target acts similar to a Marble "blueprint", in that it is the top-level container).\
Another difference is that the snapshot makes no distinction between build files and file references.  Instead, the build phases in the snapshot contain the result of flattening out any cases a single build file mapping to multiple file references, so that there is a "build file reference" for each combination.  This makes the dependency setup logic much simpler, and is again quite similar to the conceptual model in Marble.\
So: a target snapshot is created synchronously, on the main thread, and then remains immutable for its entire lifetime.  An independent snapshot is created for each target; there are no direct references between objects in different snapshots.  When the project model data changes, the target discards its snapshots and schedules idle-time creation of new ones.  The target snapshot is tailored to a specific build action and build configuration, as well as other project overriding settings (e.g. overriding SDK, active architecture, etc).\
There are two distinct phases of target snapshots:  creation and usage.\
Creation involves access to the main API of the project model classes, and is always carried out synchronously by the main thread.  It's an "instantaneous" event \'97 the snapshot is created all at once, and is subsequently not modified or augmented.\
Usage, by which we mainly mean dependency analysis and other build-related activities, involves access to the properties and methods of the snapshot (but specifically 
\b not
\b0  of the project model objects from which the snapshot was created).  Usage treats the snapshot as a pure, immutable input, and derives other information from it (and from other sources, such as build info repositories).\
The source code has been structured so that the dependency analysis implementation files avoid importing the headers that declare the project model APIs \'97 instead, they just import the headers that declare the snapshot APIs.  This reduces the risk of accidentally invoking thread-unsafe project model methods from a background build thread.}